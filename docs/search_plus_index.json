{"./":{"url":"./","title":"Introduction","keywords":"","body":"简介 日常学习笔记： 高并发方向 当前进度： [ ] SpringCloud [ ] Netty [ ] Zookeeper [ ] RocktMQ [ ] kafaka [ ] SpringCloud Alibaba [ ] Dubbo [ ] Docker Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-21 19:29:14 "},"book/":{"url":"book/","title":"简介","keywords":"","body":"简介 日常学习笔记 Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-20 22:40:12 "},"book/IO/":{"url":"book/IO/","title":"IO","keywords":"","body":"IO学习 IO相关的笔记 [ ] NIO & BIO Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-21 18:57:36 "},"book/IO/first.html":{"url":"book/IO/first.html","title":"first","keywords":"","body":"IO 用户程序进行IO读写依赖read,write两个系统调用read系统调用: graph TB 用户程序 --调用--> A[\"系统调用: read\"] A --> 内核缓存 内核缓存 --> 应用程序的进程缓冲区 write系统调用： graph TB 用户程序 --调用--> A[\"系统调用: write\"] A --> 应用程序的进程缓冲区 应用程序的进程缓冲区 --> 内核缓存 应用程序的IO操作实际上并不是物理设备级别的读写，而是缓存的复制 read & write 两个系统调用都不负责内核缓冲区和物理设备之间的交换 所有底层的读写操作，是由操作系统内核完成的 Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-21 19:12:13 "}}