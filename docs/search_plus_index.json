{"./":{"url":"./","title":"Introduction","keywords":"","body":"简介 日常学习笔记： 高并发方向 当前进度： [ ] SpringCloud [ ] Netty [ ] Zookeeper [ ] RocktMQ [ ] kafaka [ ] SpringCloud Alibaba [ ] Dubbo [ ] Docker Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-22 08:50:34 "},"book/":{"url":"book/","title":"简介","keywords":"","body":"简介 日常学习笔记 Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-22 08:50:34 "},"book/IO/":{"url":"book/IO/","title":"IO","keywords":"","body":"IO学习 IO相关的笔记 [ ] NIO & BIO Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-22 08:50:34 "},"book/IO/first.html":{"url":"book/IO/first.html","title":"first","keywords":"","body":"IO 用户程序进行IO读写依赖read,write两个系统调用read系统调用: graph TB 用户程序 --调用--> A[\"系统调用: read\"] A --> 内核缓存 内核缓存 --> 应用程序的进程缓冲区 write系统调用： graph TB 用户程序 --调用--> A[\"系统调用: write\"] A --> 应用程序的进程缓冲区 应用程序的进程缓冲区 --> 内核缓存 应用程序的IO操作实际上并不是物理设备级别的读写，而是缓存的复制 read & write 两个系统调用都不负责内核缓冲区和物理设备之间的交换 所有底层的读写操作，是由操作系统内核完成的 Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-22 08:50:34 "},"book/File/":{"url":"book/File/","title":"File","keywords":"","body":"File 文件相关 Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-23 18:20:49 "},"book/File/断点续传.html":{"url":"book/File/断点续传.html","title":"断点续传","keywords":"","body":" package com.seeyouweb.mvc; import org.apache.catalina.connector.ClientAbortException; import org.springframework.boot.SpringApplication; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestHeader; import org.springframework.web.bind.annotation.RequestMapping; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.BufferedOutputStream; import java.io.File; import java.io.IOException; import java.io.RandomAccessFile; @Controller public class Main { public static void main(String[] args) { SpringApplication.run(Main.class, args); } @RequestMapping(\"/\") void home(HttpServletRequest request, HttpServletResponse response, @RequestHeader(required = false) String range) { //文件位置 File music = new File(\"E:\\\\CloudMusic\\\\林子祥 - 街头霸王榜.mp3\"); //开始下载位置 long startByte = 0; //结束下载位置 long endByte = music.length() - 1; //有range的话 if (range != null && range.contains(\"bytes=\") && range.contains(\"-\")) { //坑爹地方一：http状态码要为206 response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT); range = range.substring(range.lastIndexOf(\"=\") + 1).trim(); String[] ranges = range.split(\"-\"); try { //判断range的类型 if (ranges.length == 1) { //类型一：bytes=-2343 if (range.startsWith(\"-\")) { endByte = Long.parseLong(ranges[0]); } //类型二：bytes=2343- else if (range.endsWith(\"-\")) { startByte = Long.parseLong(ranges[0]); } } //类型三：bytes=22-2343 else if (ranges.length == 2) { startByte = Long.parseLong(ranges[0]); endByte = Long.parseLong(ranges[1]); } } catch (NumberFormatException e) { startByte = 0; endByte = music.length() - 1; } } else { //没有ranges即全部一次性传输，需要用200状态码，这一行应该可以省掉，因为默认返回是200状态码 response.setStatus(HttpServletResponse.SC_OK); } //要下载的长度（endByte为总长度-1，这时候要加回去） long contentLength = endByte - startByte + 1; //文件名 String fileName = music.getName(); //文件类型 String contentType = request.getServletContext().getMimeType(fileName); //各种响应头设置 //参考资料：https://www.ibm.com/developerworks/cn/java/joy-down/index.html //坑爹地方二：看代码 response.setHeader(\"Accept-Ranges\", \"bytes\"); response.setContentType(contentType); response.setHeader(\"Content-Type\", contentType); //这里文件名换你想要的，inline表示浏览器可以直接使用（比如播放音乐，我方便测试用的） //参考资料：http://hw1287789687.iteye.com/blog/2188500 response.setHeader(\"Content-Disposition\", \"inline;filename=test.mp3\"); response.setHeader(\"Content-Length\", String.valueOf(contentLength)); //坑爹地方三：Content-Range，格式为 // [要下载的开始位置]-[结束位置]/[文件总大小] response.setHeader(\"Content-Range\", \"bytes \" + startByte + \"-\" + endByte + \"/\" + music.length()); BufferedOutputStream outputStream = null; RandomAccessFile randomAccessFile = null; //已传送数据大小 long transmitted = 0; try { randomAccessFile = new RandomAccessFile(music, \"r\"); outputStream = new BufferedOutputStream(response.getOutputStream()); byte[] buff = new byte[4096]; int len = 0; randomAccessFile.seek(startByte); //坑爹地方四：判断是否到了最后不足4096（buff的length）个byte这个逻辑（(transmitted + len) Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-24 09:14:32 "},"book/SpringCloud/":{"url":"book/SpringCloud/","title":"SpringCloud","keywords":"","body":"SpringCloud 微服务学习笔记 SpringCloud版本 SpringCloud Springboot 2020.0.x aka Ilford 2.4.x, 2.5.x (Starting with 2020.0.3) Hoxton 2.2.x, 2.3.x (Starting with SR5) Greenwich 2.1.x Finchley 2.0.x Edgware 1.5.x Dalston 1.5.x Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-22 10:42:56 "},"book/SpringCloud/服务治理.html":{"url":"book/SpringCloud/服务治理.html","title":"服务治理","keywords":"","body":"服务治理 SpringCloud为服务治理提供了一层抽象接口，所以在SpringCloud应用中可以支持多种不同的服务治理框架：Netflix Eureka Consul Zookeeper。在SpringCloud服务治理抽象层的作用下，可以无缝切换服务治理实现，而不影响服务注册、服务发现、服务调用等逻辑。 SpringCloud Eureka SpringCloud Eureka 是 SpringCloud Netflix项目下的服务治理模块，此子项目主要提供的模块：服务发现（Eureka） 断路器（Hystrix） 智能路由（Zuul） 负载均衡（Ribbon） 服务注册中心 创建SpringBoot项目，在pom.xml引入依赖（需要注意SpringCloud版本和Springboot版本对应） org.springframework.boot spring-boot-starter-parent 2.5.4 org.springframework.cloud spring-cloud-starter-consul-discovery org.springframework.cloud spring-cloud-dependencies 2020.0.3 pom import 通过@EnableEurekaServer注解启动一个服务注册中心 @EnableEurekaServer @SpringBootApplication public class EurekaServerApplication { public static void main(String[] args) { SpringApplication.run(EurekaServerApplication.class, args); } } 在默认配置下Eureka服务中心会将自己作为客户端进行注册，所以需要禁用它的客户端注册行为，在application.yml配置文件中进行配置 server: port: 1001 //应用端口 spring: application: name: eureka-server eureka: instance: hostname: localhost client: register-with-eureka: false fetch-registry: false server: enable-self-preservation: false //关闭自我保护 启动项目后，访问 http://127.0.0.1:1001,可以看到下面画面 创建服务提供者（Provider） 创建一个SpringBoot项目，也可以在上个服务中心项目中添加module,在pom.xml中添加以下依赖 org.springframework.boot spring-boot-starter-parent 2.5.4 org.springframework.boot spring-boot-starter-web org.springframework.cloud spring-cloud-starter-netflix-eureka-client org.springframework.cloud spring-cloud-dependencies 2020.0.3 pom import 创建Controller @RestController public class DCController { @Autowired DiscoveryClient discoveryClient; //SpringCloud提供的抽象借口，依赖此接口可以随意更换服务治理实现而不修改代码 @GetMapping(\"/dc\") public String dc(){ String services = \"Services: \" + discoveryClient.getServices(); System.out.println(services); return services; } } 在应用主类上添加@EnableEurekaClient注解 @EnableEurekaClient @SpringBootApplication public class EurekaClientApplication { public static void main(String[] args) { SpringApplication.run(EurekaClientApplication.class, args); } } 做完这些后，还需要配置application.yml文件 spring: application: name: eureka-client server: port: 8001 eureka: client: service-url: defaultZone: http://127.0.0.1:1001/eureka/ 启动该项目后，在此进入 http://127.0.0.1:1001，可以看到创建的服务成功进行了注册 SpringCloud Consul Spring Cloud Consul 项目是针对 Consul 的服务治理实现。Consul 是一个分布式高可用的系统，它包含多个组件，但是作为一个整体，在微服务架构中，为我们的基础设施提供服务发现和服务配置的工具。 Feature Euerka Consul 服务健康检查 可配支持 服务状态，内存，硬盘等 多数据中心 — 支持 kv 存储服务 — 支持 一致性 — raft cap ap cp 使用接口(多语言能力) http（sidecar） 支持 http 和 dns watch支持 支持 long polling/大部分增量 全量/支持long polling 自身监控 metrics metrics 安全 — acl/https 编程语言 Java go Spring Cloud集成 已支持 已支持 安装Consul 在官网下载：下载 解压后，得到consul.exe程序，在当前路径下打开命令行窗口 使用consul agent -dev启动consul 修改服务提供者（Provider） 在pom.xml添加依赖，并移除Eureka Client依赖 org.springframework.cloud spring-cloud-starter-consul-discovery 3.0.3 添加配置application.yml,不需要移除 eureka 的配置 spring: application: name: eureka-client cloud: consul: host: localhost port: 8500 server: port: 8001 eureka: client: service-url: defaultZone: http://127.0.0.1:1001/eureka/ 移除主类中@EnableEurekaClient注解即可，得益于SpringCloud对服务治理的抽象层，该项目已经完成转换Consul作为服务治理的实现。 Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-22 15:28:17 "},"book/SpringCloud/服务消费.html":{"url":"book/SpringCloud/服务消费.html","title":"服务消费","keywords":"","body":"服务消费 在前面完成了服务发现及服务提供者，在本章将完成服务消费者 添加依赖 pom.xml org.springframework.boot spring-boot-starter-web org.springframework.cloud spring-cloud-starter-netflix-eureka-client 配置文件 application.yml server: port: 9001 spring: application: name: eureka-consumer eureka: client: service-url: defaultZone: http://127.0.0.1:1001/eureka/ 在主类中添加注解@EnableEurekaClient, 创建RestTemplate Bean, 用于真正发起REST请求 @EnableEurekaClient @SpringBootApplication public class EurekaConsumerApplication { @Bean public RestTemplate restTemplate(){ return new RestTemplate(); } public static void main(String[] args) { SpringApplication.run(EurekaConsumerApplication.class, args); } } 创建Controller @RestController public class DCController { @Autowired LoadBalancerClient loadBalancerClient; @Autowired RestTemplate restTemplate; @GetMapping(\"/consumer\") public String dc(){ ServiceInstance instance = loadBalancerClient.choose(\"eureka-client\"); String url = \"http://\"+instance.getHost()+\":\"+instance.getPort()+\"/dc\"; System.out.println(url); return restTemplate.getForObject(url,String.class); } } LoadBalancerClient 与 DiscoveryClient 一样作为SpringCloud提供的抽象层接口，LoadBalancerClient如其名，可以看出是一个负载均衡客户端的抽象定义，在这里使用了SpringCloud提供的负载均衡客户端的实现BlockingLoadBalancerClient。 在消费者的controller中，注入了LoadBalancerClient和RestTemplate, 在'/consumer'的实现中，先通过 loadBalancerClient 的 choose 获取到一个 eureka-client的实例，然后通过对象中的信息拼接处'/dc'接口的详细信息，最后再利用RestTemplate的对象完成对服务提供者接口的调用 Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-24 10:58:15 "},"book/SpringCloud/服务消费Ribbon.html":{"url":"book/SpringCloud/服务消费Ribbon.html","title":"服务消费(Ribbon)","keywords":"","body":"服务消费(Ribbon) 在服务消费中，通过LoadBalancerClient接口来获取某个服务的实例，并根据实例信息来发起服务接口消费请求，通过手动的去编写服务选取、链接拼接，这些有点太过繁琐， Ribbon SpringCloud Ribbon是Netflix Ribbon实现的一套客户端负载均衡工具。它是基于HTTP和TCP的客户端负载均衡器，可以通过在客户端中配置ribbonServerList来设置服务端列表去轮询访问以达到均衡负载的作用。 当Ribbon与Eureka联合使用时，ribbonServerList会被DiscoveryEnabledNIWSServerList重写，扩展成从Eureka注册中心中获取服务实例列表。同时它也会用NIWSDiscoveryPing来取代IPing，它将职责委托给Eureka来确定服务端是否已经启动。 而当Ribbon与Consul联合使用时，ribbonServerList会被ConsulServerList来扩展成从Consul获取服务实例列表。同时由ConsulPing来作为IPing接口的实现。 在使用Spring Cloud Ribbon的时候，不论是与Eureka还是Consul结合，都会在引入Spring Cloud Eureka或Spring Cloud Consul依赖的时候通过自动化配置来加载上述所说的配置内容，所以我们可以快速在Spring Cloud中实现服务间调用的负载均衡 开始配置Ribbon 复制eureka-consumer项目，命名为eureka-consumer-ribbon，在pom.xml文件中引入依赖 org.springframework.cloud spring-cloud-starter-netflix-ribbon 2.2.9.RELEASE 注意！这里将会出现问题 修改主类，为RestTemplate添加@LoadBalanced注解 @EnableDiscoveryClient @SpringBootApplication public class EurekaConsumerribbonApplication { @Bean @LoadBalanced public RestTemplate restTemplate(){ return new RestTemplate(); } public static void main(String[] args) { SpringApplication.run(EurekaConsumerribbonApplication.class, args); } } 修改Controller，移除LoadBalancerClient相关代码 @RestController public class DCController { @Autowired RestTemplate restTemplate; @GetMapping(\"/consumer\") public String dc(){ return restTemplate.getForObject(\"http://eureka-client/dc\",String.class); } } 启动服务 依次开启eureka-server,eureka-client,eureka-consumer-ribbon,访问http://localhost:9001/consumer 发现错误！ java.lang.IllegalStateException: No instances available for eureka-client at org.springframework.cloud.netflix.ribbon.RibbonLoadBalancerClient.execute(RibbonLoadBalancerClient.java:119) ~[spring-cloud-netflix-ribbon-2.2.9.RELEASE.jar:2.2.9.RELEASE] at org.springframework.cloud.netflix.ribbon.RibbonLoadBalancerClient.execute(RibbonLoadBalancerClient.java:99) ~[spring-cloud-netflix-ribbon-2.2.9.RELEASE.jar:2.2.9.RELEASE] at org.springframework.cloud.client.loadbalancer.LoadBalancerInterceptor.intercept(LoadBalancerInterceptor.java:56) ~[spring-cloud-commons-3.0.3.jar:3.0.3] at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:93) ~[spring-web-5.3.9.jar:5.3.9] at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:77) ~[spring-web-5.3.9.jar:5.3.9] ........ 原因是导入的spring-cloud-starter-netflix-eureka-client包中已经包含Ribbon,移除Ribbon依赖即可。 最终的pom.xml文件 4.0.0 org.springframework.boot spring-boot-starter-parent 2.5.4 com.example eureka-consumer-ribbon 0.0.1-SNAPSHOT eureka-consumer-ribbon eureka-consumer-ribbon 1.8 2020.0.3 org.springframework.boot spring-boot-starter-web org.springframework.cloud spring-cloud-starter-netflix-eureka-client org.springframework.boot spring-boot-starter-test test org.springframework.cloud spring-cloud-dependencies ${spring-cloud.version} pom import org.springframework.boot spring-boot-maven-plugin Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-24 13:04:48 "},"book/SpringCloud/服务消费Feign.html":{"url":"book/SpringCloud/服务消费Feign.html","title":"服务消费(Feign)","keywords":"","body":"OpenFeign Spring Cloud Feign是一套基于Netflix Feign实现的声明式服务调用客户端。它使得编写Web服务客户端变得更加简单。我们只需要通过创建接口并用注解来配置它既可完成对Web服务接口的绑定。它具备可插拔的注解支持，包括Feign注解、JAX-RS注解。它也支持可插拔的编码器和解码器。Spring Cloud Feign还扩展了对Spring MVC注解的支持，同时还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。 复制一份eureka-consumer工程，命名为eureka-consuner-feign 在pom.xml中添加依赖 org.springframework.cloud spring-cloud-starter-openfeign 修改主类，添加@EnableFeignClients注解开启扫描Feigin客户端的功能 @EnableDiscoveryClient @EnableFeignClients @SpringBootApplication public class EurekaConsumerFeignApplication { @Bean public RestTemplate restTemplate(){ return new RestTemplate(); } public static void main(String[] args) { SpringApplication.run(EurekaConsumerFeignApplication.class, args); } } 创建Feign客户端接口 @FeignClient(\"eureka-client\") public interface DcClient { @GetMapping(\"/dc\") String consumer(); } 修改Controller,通过Feign客户端来调用服务提供方的接口 @RestController public class DCController { @Autowired DcClient dcClient; @GetMapping(\"/consumer\") public String dc(){ return dcClient.consumer(); } } Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-24 13:44:27 "},"book/SpringCloud/配置中心.html":{"url":"book/SpringCloud/配置中心.html","title":"配置中心","keywords":"","body":"配置中心 Spring Cloud Config是Spring Cloud团队创建的一个全新项目，用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，它分为服务端与客户端两个部分。其中服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密/解密信息等访问接口；而客户端则是微服务架构中的各个微服务应用或基础设施，它们通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。Spring Cloud Config实现了对服务端和客户端中环境变量和属性配置的抽象映射，所以它除了适用于Spring构建的应用程序之外，也可以在任何其他语言运行的应用程序中使用。由于Spring Cloud Config实现的配置中心默认采用Git来存储配置信息，所以使用Spring Cloud Config构建的配置服务器，天然就支持对微服务应用配置信息的版本管理，并且可以通过Git客户端工具来方便的管理和访问配置内容。当然它也提供了对其他存储方式的支持，比如：SVN仓库、本地化文件系统。 准备配置仓库 在github或gitee上创建一个仓库，然后创建文件，配置文件的名字需要和config的client端的application name一致 config-client.yml: info: profile: default config-client-dev.yml info: profile: dev 构建配置中心 创建SpringBoot工程，命名为：config-server-git，添加依赖 org.springframework.cloud spring-cloud-config-server 在主类上添加@EnableConfigServer注解 @EnableConfigServer @SpringBootApplication public class ConfigServerGitApplication { public static void main(String[] args) { SpringApplication.run(ConfigServerGitApplication.class, args); } } 在application.yml中添加配置服务相关信息 server: port: 10001 spring: application: name: config-server cloud: config: server: git: uri: https://gitee.com/gevikhn/config-repo-demp.git 至此，已经可以通过Config Server来访问配置内容了，不过SpringCloud Config有着它特有的一套访问规则 /{application}/{profile}[/{label}] /{application}-{profile}.yml /{label}/{application}-{profile}.yml /{application}-{profile}.properties /{label}/{application}-{profile}.properties application即应用名称，也为配置文件的文件名 profile是配置文件的版本，项目存在开发环境版本、测试环境版本、生产环境版本，配置文件也存在对应的版本，使用application-{profile}.yml 加以区分, 如application-dev.yml、application-sit.yml、application-prod.yml 访问http://localhost:10001/config-client/dev { \"name\": \"config-client\", \"profiles\": [ \"dev\" ], \"label\": null, \"version\": \"46f37b16392eb82553fe427db66f93fc83de55f3\", \"state\": null, \"propertySources\": [ { \"name\": \"https://gitee.com/gevikhn/config-repo-demp.git/file:C:\\\\Users\\\\ciallo\\\\AppData\\\\Local\\\\Temp\\\\config-repo-7200414626278387742\\\\config-client-dev.yml\", \"source\": { \"info.profile\": \"dev\" } }, { \"name\": \"https://gitee.com/gevikhn/config-repo-demp.git/file:C:\\\\Users\\\\ciallo\\\\AppData\\\\Local\\\\Temp\\\\config-repo-7200414626278387742\\\\config-client.yml\", \"source\": { \"info.profile\": \"default\" } } ] } 构建客户端 创建一个SpringBoot工程，命名为config-client，并引入依赖 org.springframework.boot spring-boot-starter-web org.springframework.cloud spring-cloud-starter-config 创建Bootstrap.xml文件，指定获取配置文件的config-server-git位置 spring: application: name: config-client cloud: config: uri: http://127.0.0.1:10001 profile: dev label: master server: port: 2001 info: profile: NaN 其中 info: profile: NaN 对应配置文件中的属性 SpringBoot在启动时我、会先加载Bootstrap.xml,然后再加载application.xml,但是在SpringCloud2.0后，SpringBoot不会默认加载Bootst.xml,需要引入依赖 org.springframework.cloud spring-cloud-starter-bootstrap 要访问配置文件的属性，可以通过@Value()注解进行 @RestController @SpringBootApplication public class ConfigClientApplication { @Value(\"${info.profile}\") //配置文件属性 String msg; public static void main(String[] args) { SpringApplication.run(ConfigClientApplication.class, args); } @GetMapping(\"/show\") public Object show(){ return msg; } } Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-24 16:43:03 "}}