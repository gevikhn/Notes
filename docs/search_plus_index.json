{"./":{"url":"./","title":"Introduction","keywords":"","body":"简介 日常学习笔记： 高并发方向 当前进度： [ ] SpringCloud [ ] Netty [ ] Zookeeper [ ] RocktMQ [ ] kafaka [ ] SpringCloud Alibaba [ ] Dubbo [ ] Docker Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-22 08:50:34 "},"book/":{"url":"book/","title":"简介","keywords":"","body":"简介 日常学习笔记 Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-22 08:50:34 "},"book/IO/":{"url":"book/IO/","title":"IO","keywords":"","body":"IO学习 IO相关的笔记 [ ] NIO & BIO Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-22 08:50:34 "},"book/IO/first.html":{"url":"book/IO/first.html","title":"first","keywords":"","body":"IO 用户程序进行IO读写依赖read,write两个系统调用read系统调用: graph TB 用户程序 --调用--> A[\"系统调用: read\"] A --> 内核缓存 内核缓存 --> 应用程序的进程缓冲区 write系统调用： graph TB 用户程序 --调用--> A[\"系统调用: write\"] A --> 应用程序的进程缓冲区 应用程序的进程缓冲区 --> 内核缓存 应用程序的IO操作实际上并不是物理设备级别的读写，而是缓存的复制 read & write 两个系统调用都不负责内核缓冲区和物理设备之间的交换 所有底层的读写操作，是由操作系统内核完成的 Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-22 08:50:34 "},"book/File/":{"url":"book/File/","title":"File","keywords":"","body":"File 文件相关 Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-23 18:20:49 "},"book/File/断点续传.html":{"url":"book/File/断点续传.html","title":"断点续传","keywords":"","body":" package com.seeyouweb.mvc; import org.apache.catalina.connector.ClientAbortException; import org.springframework.boot.SpringApplication; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestHeader; import org.springframework.web.bind.annotation.RequestMapping; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.BufferedOutputStream; import java.io.File; import java.io.IOException; import java.io.RandomAccessFile; @Controller public class Main { public static void main(String[] args) { SpringApplication.run(Main.class, args); } @RequestMapping(\"/\") void home(HttpServletRequest request, HttpServletResponse response, @RequestHeader(required = false) String range) { //文件位置 File music = new File(\"E:\\\\CloudMusic\\\\林子祥 - 街头霸王榜.mp3\"); //开始下载位置 long startByte = 0; //结束下载位置 long endByte = music.length() - 1; //有range的话 if (range != null && range.contains(\"bytes=\") && range.contains(\"-\")) { //坑爹地方一：http状态码要为206 response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT); range = range.substring(range.lastIndexOf(\"=\") + 1).trim(); String[] ranges = range.split(\"-\"); try { //判断range的类型 if (ranges.length == 1) { //类型一：bytes=-2343 if (range.startsWith(\"-\")) { endByte = Long.parseLong(ranges[0]); } //类型二：bytes=2343- else if (range.endsWith(\"-\")) { startByte = Long.parseLong(ranges[0]); } } //类型三：bytes=22-2343 else if (ranges.length == 2) { startByte = Long.parseLong(ranges[0]); endByte = Long.parseLong(ranges[1]); } } catch (NumberFormatException e) { startByte = 0; endByte = music.length() - 1; } } else { //没有ranges即全部一次性传输，需要用200状态码，这一行应该可以省掉，因为默认返回是200状态码 response.setStatus(HttpServletResponse.SC_OK); } //要下载的长度（endByte为总长度-1，这时候要加回去） long contentLength = endByte - startByte + 1; //文件名 String fileName = music.getName(); //文件类型 String contentType = request.getServletContext().getMimeType(fileName); //各种响应头设置 //参考资料：https://www.ibm.com/developerworks/cn/java/joy-down/index.html //坑爹地方二：看代码 response.setHeader(\"Accept-Ranges\", \"bytes\"); response.setContentType(contentType); response.setHeader(\"Content-Type\", contentType); //这里文件名换你想要的，inline表示浏览器可以直接使用（比如播放音乐，我方便测试用的） //参考资料：http://hw1287789687.iteye.com/blog/2188500 response.setHeader(\"Content-Disposition\", \"inline;filename=test.mp3\"); response.setHeader(\"Content-Length\", String.valueOf(contentLength)); //坑爹地方三：Content-Range，格式为 // [要下载的开始位置]-[结束位置]/[文件总大小] response.setHeader(\"Content-Range\", \"bytes \" + startByte + \"-\" + endByte + \"/\" + music.length()); BufferedOutputStream outputStream = null; RandomAccessFile randomAccessFile = null; //已传送数据大小 long transmitted = 0; try { randomAccessFile = new RandomAccessFile(music, \"r\"); outputStream = new BufferedOutputStream(response.getOutputStream()); byte[] buff = new byte[4096]; int len = 0; randomAccessFile.seek(startByte); //坑爹地方四：判断是否到了最后不足4096（buff的length）个byte这个逻辑（(transmitted + len) Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-24 09:14:32 "},"book/SpringCloud/":{"url":"book/SpringCloud/","title":"SpringCloud","keywords":"","body":"SpringCloud 微服务学习笔记 SpringCloud版本 SpringCloud Springboot 2020.0.x aka Ilford 2.4.x, 2.5.x (Starting with 2020.0.3) Hoxton 2.2.x, 2.3.x (Starting with SR5) Greenwich 2.1.x Finchley 2.0.x Edgware 1.5.x Dalston 1.5.x Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-22 10:42:56 "},"book/SpringCloud/服务治理.html":{"url":"book/SpringCloud/服务治理.html","title":"服务治理","keywords":"","body":"服务治理 SpringCloud为服务治理提供了一层抽象接口，所以在SpringCloud应用中可以支持多种不同的服务治理框架：Netflix Eureka Consul Zookeeper。在SpringCloud服务治理抽象层的作用下，可以无缝切换服务治理实现，而不影响服务注册、服务发现、服务调用等逻辑。 SpringCloud Eureka SpringCloud Eureka 是 SpringCloud Netflix项目下的服务治理模块，此子项目主要提供的模块：服务发现（Eureka） 断路器（Hystrix） 智能路由（Zuul） 负载均衡（Ribbon） 服务注册中心 创建SpringBoot项目，在pom.xml引入依赖（需要注意SpringCloud版本和Springboot版本对应） org.springframework.boot spring-boot-starter-parent 2.5.4 org.springframework.cloud spring-cloud-starter-consul-discovery org.springframework.cloud spring-cloud-dependencies 2020.0.3 pom import 通过@EnableEurekaServer注解启动一个服务注册中心 @EnableEurekaServer @SpringBootApplication public class EurekaServerApplication { public static void main(String[] args) { SpringApplication.run(EurekaServerApplication.class, args); } } 在默认配置下Eureka服务中心会将自己作为客户端进行注册，所以需要禁用它的客户端注册行为，在application.yml配置文件中进行配置 server: port: 1001 //应用端口 spring: application: name: eureka-server eureka: instance: hostname: localhost client: register-with-eureka: false fetch-registry: false server: enable-self-preservation: false //关闭自我保护 启动项目后，访问 http://127.0.0.1:1001,可以看到下面画面 创建服务提供者（Provider） 创建一个SpringBoot项目，也可以在上个服务中心项目中添加module,在pom.xml中添加以下依赖 org.springframework.boot spring-boot-starter-parent 2.5.4 org.springframework.boot spring-boot-starter-web org.springframework.cloud spring-cloud-starter-netflix-eureka-client org.springframework.cloud spring-cloud-dependencies 2020.0.3 pom import 创建Controller @RestController public class DCController { @Autowired DiscoveryClient discoveryClient; //SpringCloud提供的抽象借口，依赖此接口可以随意更换服务治理实现而不修改代码 @GetMapping(\"/dc\") public String dc(){ String services = \"Services: \" + discoveryClient.getServices(); System.out.println(services); return services; } } 在应用主类上添加@EnableEurekaClient注解 @EnableEurekaClient @SpringBootApplication public class EurekaClientApplication { public static void main(String[] args) { SpringApplication.run(EurekaClientApplication.class, args); } } 做完这些后，还需要配置application.yml文件 spring: application: name: eureka-client server: port: 8001 eureka: client: service-url: defaultZone: http://127.0.0.1:1001/eureka/ 启动该项目后，在此进入 http://127.0.0.1:1001，可以看到创建的服务成功进行了注册 SpringCloud Consul Spring Cloud Consul 项目是针对 Consul 的服务治理实现。Consul 是一个分布式高可用的系统，它包含多个组件，但是作为一个整体，在微服务架构中，为我们的基础设施提供服务发现和服务配置的工具。 Feature Euerka Consul 服务健康检查 可配支持 服务状态，内存，硬盘等 多数据中心 — 支持 kv 存储服务 — 支持 一致性 — raft cap ap cp 使用接口(多语言能力) http（sidecar） 支持 http 和 dns watch支持 支持 long polling/大部分增量 全量/支持long polling 自身监控 metrics metrics 安全 — acl/https 编程语言 Java go Spring Cloud集成 已支持 已支持 安装Consul 在官网下载：下载 解压后，得到consul.exe程序，在当前路径下打开命令行窗口 使用consul agent -dev启动consul 修改服务提供者（Provider） 在pom.xml添加依赖，并移除Eureka Client依赖 org.springframework.cloud spring-cloud-starter-consul-discovery 3.0.3 添加配置application.yml,不需要移除 eureka 的配置 spring: application: name: eureka-client cloud: consul: host: localhost port: 8500 server: port: 8001 eureka: client: service-url: defaultZone: http://127.0.0.1:1001/eureka/ 移除主类中@EnableEurekaClient注解即可，得益于SpringCloud对服务治理的抽象层，该项目已经完成转换Consul作为服务治理的实现。 Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-22 15:28:17 "},"book/SpringCloud/服务消费.html":{"url":"book/SpringCloud/服务消费.html","title":"服务消费","keywords":"","body":"服务消费 在前面完成了服务发现及服务提供者，在本章将完成服务消费者 添加依赖 pom.xml org.springframework.boot spring-boot-starter-web org.springframework.cloud spring-cloud-starter-netflix-eureka-client 配置文件 application.yml server: port: 9001 spring: application: name: eureka-consumer eureka: client: service-url: defaultZone: http://127.0.0.1:1001/eureka/ 在主类中添加注解@EnableEurekaClient, 创建RestTemplate Bean, 用于真正发起REST请求 @EnableEurekaClient @SpringBootApplication public class EurekaConsumerApplication { @Bean public RestTemplate restTemplate(){ return new RestTemplate(); } public static void main(String[] args) { SpringApplication.run(EurekaConsumerApplication.class, args); } } 创建Controller @RestController public class DCController { @Autowired LoadBalancerClient loadBalancerClient; @Autowired RestTemplate restTemplate; @GetMapping(\"/consumer\") public String dc(){ ServiceInstance instance = loadBalancerClient.choose(\"eureka-client\"); String url = \"http://\"+instance.getHost()+\":\"+instance.getPort()+\"/dc\"; System.out.println(url); return restTemplate.getForObject(url,String.class); } } LoadBalancerClient 与 DiscoveryClient 一样作为SpringCloud提供的抽象层接口，LoadBalancerClient如其名，可以看出是一个负载均衡客户端的抽象定义，在这里使用了SpringCloud提供的负载均衡客户端的实现BlockingLoadBalancerClient。 在消费者的controller中，注入了LoadBalancerClient和RestTemplate, 在'/consumer'的实现中，先通过 loadBalancerClient 的 choose 获取到一个 eureka-client的实例，然后通过对象中的信息拼接处'/dc'接口的详细信息，最后再利用RestTemplate的对象完成对服务提供者接口的调用 Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-24 10:58:15 "},"book/SpringCloud/服务消费Ribbon.html":{"url":"book/SpringCloud/服务消费Ribbon.html","title":"服务消费(Ribbon)","keywords":"","body":"服务消费(Ribbon) 在服务消费中，通过LoadBalancerClient接口来获取某个服务的实例，并根据实例信息来发起服务接口消费请求，通过手动的去编写服务选取、链接拼接，这些有点太过繁琐， Ribbon SpringCloud Ribbon是Netflix Ribbon实现的一套客户端负载均衡工具。它是基于HTTP和TCP的客户端负载均衡器，可以通过在客户端中配置ribbonServerList来设置服务端列表去轮询访问以达到均衡负载的作用。 当Ribbon与Eureka联合使用时，ribbonServerList会被DiscoveryEnabledNIWSServerList重写，扩展成从Eureka注册中心中获取服务实例列表。同时它也会用NIWSDiscoveryPing来取代IPing，它将职责委托给Eureka来确定服务端是否已经启动。 而当Ribbon与Consul联合使用时，ribbonServerList会被ConsulServerList来扩展成从Consul获取服务实例列表。同时由ConsulPing来作为IPing接口的实现。 在使用Spring Cloud Ribbon的时候，不论是与Eureka还是Consul结合，都会在引入Spring Cloud Eureka或Spring Cloud Consul依赖的时候通过自动化配置来加载上述所说的配置内容，所以我们可以快速在Spring Cloud中实现服务间调用的负载均衡 开始配置Ribbon 复制eureka-consumer项目，命名为eureka-consumer-ribbon，在pom.xml文件中引入依赖 org.springframework.cloud spring-cloud-starter-netflix-ribbon 2.2.9.RELEASE 注意！这里将会出现问题 修改主类，为RestTemplate添加@LoadBalanced注解 @EnableDiscoveryClient @SpringBootApplication public class EurekaConsumerribbonApplication { @Bean @LoadBalanced public RestTemplate restTemplate(){ return new RestTemplate(); } public static void main(String[] args) { SpringApplication.run(EurekaConsumerribbonApplication.class, args); } } 修改Controller，移除LoadBalancerClient相关代码 @RestController public class DCController { @Autowired RestTemplate restTemplate; @GetMapping(\"/consumer\") public String dc(){ return restTemplate.getForObject(\"http://eureka-client/dc\",String.class); } } 启动服务 依次开启eureka-server,eureka-client,eureka-consumer-ribbon,访问http://localhost:9001/consumer 发现错误！ java.lang.IllegalStateException: No instances available for eureka-client at org.springframework.cloud.netflix.ribbon.RibbonLoadBalancerClient.execute(RibbonLoadBalancerClient.java:119) ~[spring-cloud-netflix-ribbon-2.2.9.RELEASE.jar:2.2.9.RELEASE] at org.springframework.cloud.netflix.ribbon.RibbonLoadBalancerClient.execute(RibbonLoadBalancerClient.java:99) ~[spring-cloud-netflix-ribbon-2.2.9.RELEASE.jar:2.2.9.RELEASE] at org.springframework.cloud.client.loadbalancer.LoadBalancerInterceptor.intercept(LoadBalancerInterceptor.java:56) ~[spring-cloud-commons-3.0.3.jar:3.0.3] at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:93) ~[spring-web-5.3.9.jar:5.3.9] at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:77) ~[spring-web-5.3.9.jar:5.3.9] ........ 原因是导入的spring-cloud-starter-netflix-eureka-client包中已经包含Ribbon,移除Ribbon依赖即可。 最终的pom.xml文件 4.0.0 org.springframework.boot spring-boot-starter-parent 2.5.4 com.example eureka-consumer-ribbon 0.0.1-SNAPSHOT eureka-consumer-ribbon eureka-consumer-ribbon 1.8 2020.0.3 org.springframework.boot spring-boot-starter-web org.springframework.cloud spring-cloud-starter-netflix-eureka-client org.springframework.boot spring-boot-starter-test test org.springframework.cloud spring-cloud-dependencies ${spring-cloud.version} pom import org.springframework.boot spring-boot-maven-plugin Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-24 13:04:48 "},"book/SpringCloud/服务消费Feign.html":{"url":"book/SpringCloud/服务消费Feign.html","title":"服务消费(Feign)","keywords":"","body":"OpenFeign Spring Cloud Feign是一套基于Netflix Feign实现的声明式服务调用客户端。它使得编写Web服务客户端变得更加简单。我们只需要通过创建接口并用注解来配置它既可完成对Web服务接口的绑定。它具备可插拔的注解支持，包括Feign注解、JAX-RS注解。它也支持可插拔的编码器和解码器。Spring Cloud Feign还扩展了对Spring MVC注解的支持，同时还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。 复制一份eureka-consumer工程，命名为eureka-consuner-feign 在pom.xml中添加依赖 org.springframework.cloud spring-cloud-starter-openfeign 修改主类，添加@EnableFeignClients注解开启扫描Feigin客户端的功能 @EnableDiscoveryClient @EnableFeignClients @SpringBootApplication public class EurekaConsumerFeignApplication { @Bean public RestTemplate restTemplate(){ return new RestTemplate(); } public static void main(String[] args) { SpringApplication.run(EurekaConsumerFeignApplication.class, args); } } 创建Feign客户端接口 @FeignClient(\"eureka-client\") public interface DcClient { @GetMapping(\"/dc\") String consumer(); } 修改Controller,通过Feign客户端来调用服务提供方的接口 @RestController public class DCController { @Autowired DcClient dcClient; @GetMapping(\"/consumer\") public String dc(){ return dcClient.consumer(); } } Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-24 13:44:27 "},"book/SpringCloud/配置中心.html":{"url":"book/SpringCloud/配置中心.html","title":"配置中心","keywords":"","body":"配置中心 Spring Cloud Config是Spring Cloud团队创建的一个全新项目，用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，它分为服务端与客户端两个部分。其中服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密/解密信息等访问接口；而客户端则是微服务架构中的各个微服务应用或基础设施，它们通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。Spring Cloud Config实现了对服务端和客户端中环境变量和属性配置的抽象映射，所以它除了适用于Spring构建的应用程序之外，也可以在任何其他语言运行的应用程序中使用。由于Spring Cloud Config实现的配置中心默认采用Git来存储配置信息，所以使用Spring Cloud Config构建的配置服务器，天然就支持对微服务应用配置信息的版本管理，并且可以通过Git客户端工具来方便的管理和访问配置内容。当然它也提供了对其他存储方式的支持，比如：SVN仓库、本地化文件系统。 准备配置仓库 在github或gitee上创建一个仓库，然后创建文件，配置文件的名字需要和config的client端的application name一致 config-client.yml: info: profile: default config-client-dev.yml info: profile: dev 构建配置中心 创建SpringBoot工程，命名为：config-server-git，添加依赖 org.springframework.cloud spring-cloud-config-server 在主类上添加@EnableConfigServer注解 @EnableConfigServer @SpringBootApplication public class ConfigServerGitApplication { public static void main(String[] args) { SpringApplication.run(ConfigServerGitApplication.class, args); } } 在application.yml中添加配置服务相关信息 server: port: 10001 spring: application: name: config-server cloud: config: server: git: uri: https://gitee.com/gevikhn/config-repo-demp.git 至此，已经可以通过Config Server来访问配置内容了，不过SpringCloud Config有着它特有的一套访问规则 /{application}/{profile}[/{label}] /{application}-{profile}.yml /{label}/{application}-{profile}.yml /{application}-{profile}.properties /{label}/{application}-{profile}.properties application即应用名称，也为配置文件的文件名 profile是配置文件的版本，项目存在开发环境版本、测试环境版本、生产环境版本，配置文件也存在对应的版本，使用application-{profile}.yml 加以区分, 如application-dev.yml、application-sit.yml、application-prod.yml 访问http://localhost:10001/config-client/dev { \"name\": \"config-client\", \"profiles\": [ \"dev\" ], \"label\": null, \"version\": \"46f37b16392eb82553fe427db66f93fc83de55f3\", \"state\": null, \"propertySources\": [ { \"name\": \"https://gitee.com/gevikhn/config-repo-demp.git/file:C:\\\\Users\\\\ciallo\\\\AppData\\\\Local\\\\Temp\\\\config-repo-7200414626278387742\\\\config-client-dev.yml\", \"source\": { \"info.profile\": \"dev\" } }, { \"name\": \"https://gitee.com/gevikhn/config-repo-demp.git/file:C:\\\\Users\\\\ciallo\\\\AppData\\\\Local\\\\Temp\\\\config-repo-7200414626278387742\\\\config-client.yml\", \"source\": { \"info.profile\": \"default\" } } ] } 构建客户端 创建一个SpringBoot工程，命名为config-client，并引入依赖 org.springframework.boot spring-boot-starter-web org.springframework.cloud spring-cloud-starter-config 创建Bootstrap.xml文件，指定获取配置文件的config-server-git位置 spring: application: name: config-client cloud: config: uri: http://127.0.0.1:10001 profile: dev label: master server: port: 2001 info: profile: NaN 其中 info: profile: NaN 对应配置文件中的属性 SpringBoot在启动时我、会先加载Bootstrap.xml,然后再加载application.xml,但是在SpringCloud2.0后，SpringBoot不会默认加载Bootst.xml,需要引入依赖 org.springframework.cloud spring-cloud-starter-bootstrap 要访问配置文件的属性，可以通过@Value()注解进行 @RestController @SpringBootApplication public class ConfigClientApplication { @Value(\"${info.profile}\") //配置文件属性 String msg; public static void main(String[] args) { SpringApplication.run(ConfigClientApplication.class, args); } @GetMapping(\"/show\") public Object show(){ return msg; } } 高可用配置中心 接入注册中心与配置刷新 config-server 首先，在pom.xml中添加eureka依赖 org.springframework.cloud spring-cloud-starter-netflix-eureka-client 然后在主类添加@EnableDiscoverClient注解，在application.yml中添加Eureka配置信息 server: port: 10001 spring: application: name: config-server cloud: config: server: git: uri: https://gitee.com/gevikhn/config-repo-demp.git encrypt: key: 666666 eureka: client: service-url: defaultZone: http://127.0.0.1:1001/eureka/ config-client 同上面一样，添加eureka client 依赖，并在主类上添加@EnableDiscoverClient注解 org.springframework.cloud spring-cloud-starter-netflix-eureka-client 3.0.4 org.springframework.boot spring-boot-starter-web org.springframework.cloud spring-cloud-starter-config org.springframework.cloud spring-cloud-starter-bootstrap org.springframework.boot spring-boot-starter-actuator 在bootstrap.yml中添加配置 ``` Java spring: application: name: config-client cloud: config: discovery: enabled: true service-id: config-server profile: dev server: port: 2001 info: profile: NaN eureka: client: service-url: defaultZone: http://127.0.0.1:1001/eureka/ management: endpoints: web: exposure: include: refresh,health,info 需要注意需要配置 management.endpoints.web.exposure.include以开启actuator来进行刷新Config 在Controller上添加`@RefreshScope`注解 ``` Java @RefreshScope @RestController public class GetConfig { @Value(\"${info.profile}\") String msg; @GetMapping(\"/show\") public Object show(){ return msg; } } 在修改配置文件后，访问http://127.0.0.1:2001/actuator/refresh即可刷新配置，访问该链接后返回 [ \"config.client.version\", \"info.profile\" ] Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-26 10:35:05 "},"book/springcloud/服务容错保护.html":{"url":"book/springcloud/服务容错保护.html","title":"服务容错保护","keywords":"","body":"服务容错保护 Hystrix服务降级 在分布式系统中，服务之间的依赖错综复杂，如果一个服务发生故障，导致依赖它的其他服务出现远程调用的线程阻塞，若此时调用方的请求不断增加，最终会形成任务积压，线程无法释放，最终导致服务瘫痪，甚至故障会蔓延到整个系统。为了解决这样的问题，因此出现了断路器等一系列服务保护机制 针对上述问题，在Spring Cloud Hystrix中实现了线程隔离、断路器等一系列的服务保护功能。它也是基于Netflix的开源框架 Hystrix实现的，该框架目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备了服务降级、服务熔断、线程隔离、请求缓存、请求合并以及服务监控等强大功能。 在之前的eureka-consumer-ribbon工程中进行改造 添加依赖 org.springframework.cloud spring-cloud-starter-netflix-hystrix 2.2.9.RELEASE 在主类添加@EnableCircuitBreaker注解 改造Controller，将之前远程调用的逻辑迁移到新类ConsumerService中 @RestController public class DCController { @Autowired ConsumerService service; @GetMapping(\"/consumer\") public String dc(){ return service.consumer(); } } @Service class ConsumerService{ @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod = \"fallback\") public String consumer(){ return restTemplate.getForObject(\"http://eureka-client/dc\",String.class); } public String fallback(){ return \"Fail\"; } } 启动服务，访问http://localhost:9001/consumer，此时可以正常获取结果，关闭服务提供者，再次访问链接，此时返回结果为Fail Hystrix依赖隔离 Hystrix除了服务降级之外，还有着线程隔离、断路器的能力 使用@HystrixCommand来将某个函数包装成了Hystrix命令，除了定义服务降级之外，Hystrix框架就会自动的为这个函数实现调用的隔离 依赖隔离、服务降级在使用时候都是一体化实现的 Htstrix断路器 断路器的三个重要参数：快照时间窗、请求总数下限、错误百分比下限。这个参数的作用分别是： 快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。 请求总数下限：在快照时间窗内，必须满足请求总数下限才有资格根据熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用此时不足20次，即时所有的请求都超时或其他原因失败，断路器都不会打开。 错误百分比下限：当请求总数在快照时间窗内超过了下限，比如发生了30次调用，如果在这30次调用中，有16次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%下限情况下，这时候就会将断路器打开。 断路器开启或关闭的条件？ 1. 当满足一定阈值时（默认10秒内超过20个请求次数） 2. 当失败率达到一定时（默认10秒内超过50%的请求失败） 3. 到达以上阈值，断路器将开启 4. 当开启时，所有请求将不会转发 5. 一段时间后（默认是5秒），这个时候断路器是半开状态，会让其中一个进行转发。如果成功，断路器会关闭，若失败，继续开启。重复4~5 断路器打开后，再次有请求调用时，将不会再调用主逻辑，而是直接调用降级逻辑。 当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑临时的成为主逻辑，当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将闭合，主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时 开启断路器 @RestController public class DCController { @Autowired ConsumerService service; @GetMapping(\"/consumer\") public String dc(){ return service.consumer(); } } @Service class ConsumerService{ @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod = \"fallback\", commandProperties = { @HystrixProperty(name = \"circuitBreaker.enabled\", value = \"true\"), @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\", value = \"5\"), @HystrixProperty(name = \"circuitBreaker.sleepWindowInMilliseconds\", value = \"100000\"), @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\", value = \"60\") }) public String consumer(){ System.out.println(\"a\"); return restTemplate.getForObject(\"http://eureka-client/dc\",String.class); } public String fallback(){ System.out.println(\"b\"); return \"Fail\"; } } Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-26 15:49:42 "},"book/SpringCloud/服务网关.html":{"url":"book/SpringCloud/服务网关.html","title":"服务网关","keywords":"","body":"服务网关 构建服务网关 在pom.xml中添加依赖 org.springframework.cloud spring-cloud-starter-netflix-eureka-client org.springframework.cloud spring-cloud-starter-netflix-zuul 在主类添加@EnableZuulProxy和@EnableDiscoveryClient注解 @EnableZuulProxy @EnableDiscoveryClient @SpringBootApplication public class ApiGatewayApplication { public static void main(String[] args) { SpringApplication.run(ApiGatewayApplication.class, args); } } 添加配置文件application.yml server: port: 1111 spring: application: name: api-gateway eureka: client: service-url: defaultZone: http://127.0.0.1:1001/eureka/ management: endpoints: web: exposure: include: \"*\" 访问http://localhost:1111/actuator/routes查看当前路由节点 { \"/eureka-consumer/**\": \"eureka-consumer\", \"/eureka-client/**\": \"eureka-client\" } 访问http://localhost:1111/eureka-consumer/consumer可以像之前一样访问消费者接口 路由配置 传统路由配置 单实例配置：通过一组zuul.routes.\\.path与zuul.routes.\\.url参数对的方式配置 \"zuul.routes.user-service.path=/user-service/**\" \"zuul.routes.user-service.url=http://localhost:8080/\" 多实例配置：通过一组zuul.routes.\\.path与zuul.routes.\\.serviceId参数对的方式配置 zuul.routes.user-service.path=/user-service/** zuul.routes.user-service.serviceId=user-service ribbon.eureka.enabled=false user-service.ribbon.listOfServers=http://localhost:8080/,http://localhost:8081/ ribbon.eureka.enabled：由于zuul.routes..serviceId指定的是服务名称，默认情况下Ribbon会根据服务发现机制来获取配置服务名对应的实例清单。但是，若没有整合类似Eureka之类的服务治理框架，需要将该参数设置为false，不然配置的serviceId是获取不到对应实例清单的。 user-service.ribbon.listOfServers：该参数内容与zuul.routes..serviceId的配置相对应，开头的user-service对应了serviceId的值，这两个参数的配置相当于在该应用内部手工维护了服务与实例的对应关系。 服务路由配置 Spring Cloud Zuul通过与Spring Cloud Eureka的整合，实现了对服务实例的自动化维护，所以在使用服务路由配置的时候，我们不需要向传统路由配置方式那样为serviceId去指定具体的服务实例地址，只需要通过一组zuul.routes..path与zuul.routes..serviceId参数对的方式配置即可 zuul.routes.user-service.path=/user-service/** zuul.routes.user-service.serviceId=user-service 对于面向服务的路由配置，除了使用path与serviceId映射的配置方式之外，还有一种更简洁的配置方式：zuul.routes.=，其中用来指定路由的具体服务名，用来配置匹配的请求表达式。 zuul.routes.user-service=/user-service/** Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-26 17:05:23 "},"book/springcloud/消息驱动的微服务.html":{"url":"book/springcloud/消息驱动的微服务.html","title":"消息驱动的微服务","keywords":"","body":"消息驱动的微服务：RabbitMQ Spring Cloud Stream 是一个用于构建基于消息的微服务应用框架，使用 Spring Integration 与 Broker 进行连接。 Spring Cloud Stream 提供了消息中间件的统一抽象，推出了 publish-subscribe、consumer groups、partition 这些统一的概念。 Spring Cloud Stream 内部有两个概念：Binder 和 Binding。 Binder，跟消息中间件集成的组件，用来创建对应的 Binding。各消息中间件都有自己的 Binder 具体实现。 Binding，包括 Input Binding 和 Output Binding。Binding 在消息中间件与应用程序提供的 Provider 和 Consumer 之间提供了一个桥梁，实现了开发者只需使用应用程序的 Provider 或 Consumer 生产或消费数据即可，屏蔽了开发者与底层消息中间件的接触。 构建生产者 在pom.xml中引入依赖 org.springframework.cloud spring-cloud-starter-stream-rabbit application.yml配置文件 spring: application: name: demo-producer-application cloud: # Spring Cloud Stream 配置项，对应 BindingServiceProperties 类 stream: # Binder 配置项，对应 BinderProperties Map binders: rabbit001: type: rabbit # 设置 Binder 的类型 environment: # 设置 Binder 的环境配置 # 如果是 RabbitMQ 类型的时候，则对应的是 RabbitProperties 类 spring: rabbitmq: host: 127.0.0.1 # RabbitMQ 服务的地址 port: 5672 # RabbitMQ 服务的端口 username: guest # RabbitMQ 服务的账号 password: guest # RabbitMQ 服务的密码 # Binding 配置项，对应 BindingProperties Map bindings: output: destination: input # 目的地。这里使用 RabbitMQ Exchange content-type: application/json # 内容格式。这里使用 JSON binder: rabbit001 # 设置使用的 Binder 名字 server: port: 18080 spring.cloud.stream为 Spring Cloud Stream 配置项，对应 BindingServiceProperties 类 spring.cloud.stream.binders为 Binder 配置项，对应 BinderProperties Map。其中 key 为 Binder 的名字 在此创建了一个名为rabbit001的binder type: Binder 的类型。设置为 rabbit，表示使用 Spring Cloud Stream RabbitMQ 提供的 Binder 实现 environment:Binder 的环境。因为 Spring Cloud Steam RabbitMQ 底层使用的是 spring-rabbit，所以在使用 RabbitMQ 类型的时候，则对应的是 RabbitProperties 类 spring.cloud.stream.bindings为 Binding 配置项，对应 BindingProperties Map。其中，key 为 Binding 的名字。要注意，虽然说 Binding 分成 Input 和 Output 两种类型，但是在配置项中并不会体现出来，而是要在稍后搭配 @Input 还是 @Output 注解，才会有具体的区分。 在此配置一个名为demo01-output的binding destination：目的地。在 RabbitMQ 中，使用 Exchange 作为目的地，默认为 Topic 类型 content-type：内容格式。这里使用 JSON 格式，因为稍后我们将发送消息的类型为 POJO，使用 JSON 进行序列化 binder：使用的 Binder 名字。这里我们设置为 rabbit001 创建MySource接口 public interface MySource { @Output(\"input\") MessageChannel demo01Output(); } 创建Controller @RestController @RequestMapping(\"/demo01\") public class SendController { private Logger logger = LoggerFactory.getLogger(getClass()); @Autowired private MySource mySource; // @GetMapping(\"/send\") public boolean send() { // 创建 Message // 创建 Spring Message 对象 Message springMessage = MessageBuilder.withPayload(\"ciallo\") .build(); // 发送消息 boolean result = mySource.demo01Output().send(springMessage); logger.info(\"[send][发送成功]\"); return result; } } 在主类上添加@EnableBinding(MySource.class)注解 构建消费者 引入依赖，与生产者依赖相同 配置文件 spring: application: name: demo-consumer-application cloud: # Spring Cloud Stream 配置项，对应 BindingServiceProperties 类 stream: # Binder 配置项，对应 BinderProperties Map binders: rabbit001: type: rabbit # 设置 Binder 的类型 environment: # 设置 Binder 的环境配置 # 如果是 RabbitMQ 类型的时候，则对应的是 RabbitProperties 类 spring: rabbitmq: host: 127.0.0.1 # RabbitMQ 服务的地址 port: 5672 # RabbitMQ 服务的端口 username: guest # RabbitMQ 服务的账号 password: guest # RabbitMQ 服务的密码 # Binding 配置项，对应 BindingProperties Map bindings: input: destination: input # 目的地。这里使用 RabbitMQ Exchange content-type: application/json # 内容格式。这里使用 JSON group: demo01-consumer-group-DEMO-TOPIC-01 # 消费者分组 binder: rabbit001 # 设置使用的 Binder 名字 server: port: ${random.int[10000,19999]} # 随机端口，方便启动多个消费者 group:消费者分组 消费者组（Consumer Group）：同一类 Consumer 的集合，这类 Consumer 通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的 Topic。 对于消费队列的消费者，会有两种消费模式：集群消费（Clustering）和广播消费（Broadcasting）。 集群消费（Clustering）：集群消费模式下,相同 Consumer Group 的每个 Consumer 实例平均分摊消息。 广播消费（Broadcasting）：广播消费模式下，相同 Consumer Group 的每个 Consumer 实例都接收全量的消息 创建消费者类 @EnableBinding(Sink.class) public class SinkReceiver { private static Logger logger = LoggerFactory.getLogger(SinkReceiver.class); @StreamListener(Sink.INPUT) public void receive(Object payload) { logger.info(\"Received: \" + payload); } } 已经能够在多实例环境下，保证同一消息只被同一个组内的一个消费者实例进行接收和处理 对于一些特殊场景，除了要保证单一实例消费之外，还希望那些具备相同特征的消息都能够被同一个实例进行消费 消息分区 在消费者工程的配置文件中添加以下配置 spring.cloud.stream.bindings.input.consumer.partitioned=true spring.cloud.stream.instanceCount=2 spring.cloud.stream.instanceIndex=0 spring.cloud.stream.bindings.input.consumer.partitioned：通过该参数开启消费者分区功能； spring.cloud.stream.instanceCount：该参数指定了当前消费者的总实例数量； spring.cloud.stream.instanceIndex：该参数设置当前实例的索引号，从0开始，最大值为spring.cloud.stream.instanceCount参数 - 1。我们试验的时候需要启动多个实例，可以通过运行参数来为不同实例设置不同的索引值(spring.cloud.stream.instanceIndex = ${INDEX:0}) 在生产者的配置文件中也做出稍许更改 spring.cloud.stream.bindings.output.producer.partitionKeyExpression=payload spring.cloud.stream.bindings.output.producer.partitionCount=2 spring.cloud.stream.bindings.output.producer.partitionKeyExpression：通过该参数指定了分区键的表达式规则，我们可以根据实际的输出消息规则来配置SpEL来生成合适的分区键(设置为payload会根据具体消息动态选择分组，也可以直接指定分区)； spring.cloud.stream.bindings.output.producer.partitionCount：该参数指定了消息分区的数量。 Ciallo all right reserved，powered by Gitbook该文章修订时间： 2021-09-28 17:23:57 "}}