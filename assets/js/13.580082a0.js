(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{467:function(n,t,e){"use strict";e.r(t);var a=e(29),r=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线程"}},[n._v("#")]),n._v(" 线程")]),n._v(" "),e("h2",{attrs:{id:"线程的状态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线程的状态"}},[n._v("#")]),n._v(" 线程的状态")]),n._v(" "),e("ol",[e("li",[e("p",[n._v("新建(new)")])]),n._v(" "),e("li",[e("p",[n._v("可运行(runnable)")])]),n._v(" "),e("li",[e("p",[n._v("运行(running)")])]),n._v(" "),e("li",[e("p",[n._v("阻塞(blocked)")]),n._v(" "),e("p",[n._v("a. 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中")]),n._v(" "),e("p",[n._v("b. 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。")]),n._v(" "),e("p",[n._v("c. 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。")])]),n._v(" "),e("li",[e("p",[n._v("死亡(dead)")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);