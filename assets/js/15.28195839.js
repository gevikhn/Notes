(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{466:function(t,a,s){"use strict";s.r(a);var n=s(29),p=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"spring事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#spring事务"}},[t._v("#")]),t._v(" Spring事务")]),t._v(" "),s("h2",{attrs:{id:"特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),s("ul",[s("li",[t._v("原子性")]),t._v(" "),s("li",[t._v("一致性")]),t._v(" "),s("li",[t._v("隔离性")]),t._v(" "),s("li",[t._v("持久性")])]),t._v(" "),s("h2",{attrs:{id:"事务的传播机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事务的传播机制"}},[t._v("#")]),t._v(" 事务的传播机制")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("REQUIRED:")]),t._v(" "),s("p",[t._v("Spring默认的传播机制，能满足绝大部分业务需求，如果外层有事务，则当前事务加入到外层事务，一块提交，一块回滚。如果外层没有事务，新建一个事务执行")])]),t._v(" "),s("li",[s("p",[t._v("REQUES_NEW:")]),t._v(" "),s("p",[t._v("该事务传播机制是每次都会新开启一个事务，同时把外层事务挂起，当当前事务执行完毕，恢复上层事务的执行。如果外层没有事务，执行当前新开启的事务即可")])]),t._v(" "),s("li",[s("p",[t._v("SUPPORT:")]),t._v(" "),s("p",[t._v("如果外层有事务，则加入外层事务，如果外层没有事务，则直接使用非事务方式执行。完全依赖外层的事务")])]),t._v(" "),s("li",[s("p",[t._v("NOT_SUPPORT")]),t._v(" "),s("p",[t._v("该传播机制不支持事务，如果外层存在事务则挂起，执行完当前代码，则恢复外层事务，无论是否异常都不会回滚当前的代码")])]),t._v(" "),s("li",[s("p",[t._v("NEVER")]),t._v(" "),s("p",[t._v("该传播机制不支持外层事务，即如果外层有事务就抛出异常")])]),t._v(" "),s("li",[s("p",[t._v("MANDATORY")]),t._v(" "),s("p",[t._v("与NEVER相反，如果外层没有事务，则抛出异常")])]),t._v(" "),s("li",[s("p",[t._v("NESTED")]),t._v(" "),s("p",[t._v("该传播机制的特点是可以保存状态保存点，当前事务回滚到某一个点，从而避免所有的嵌套事务都回滚，即各自回滚各自的，如果子事务没有把异常吃掉，基本还是会引起全部回滚的。")])])]),t._v(" "),s("h2",{attrs:{id:"事务可能引发的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事务可能引发的问题"}},[t._v("#")]),t._v(" 事务可能引发的问题")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("脏读：")]),t._v(" "),s("p",[t._v("脏读发生在一个事务读取了被另一个事务改写但尚未提交的数据时。如果这些改变在稍后被回滚了，那么第一个事务读取的数据就会是无效的。")])]),t._v(" "),s("li",[s("p",[t._v("幻读：")]),t._v(" "),s("p",[t._v("当一个事务（T1）读取几行记录后，另一个并发事务（T2）插入了一些记录时，幻读就发生了。在后来的查询中，第一个事务（T1）就会发现一些原来没有的额外记录。")])]),t._v(" "),s("li",[s("p",[t._v("不可重复读：")]),t._v(" "),s("p",[t._v("不可重复读发生在一个事务执行相同的查询两次或两次以上，但每次查询结果都不相同时。这通常是由于另一个并发事务在两次查询之间更新了数据。")])])]),t._v(" "),s("h2",{attrs:{id:"隔离级别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#隔离级别"}},[t._v("#")]),t._v(" 隔离级别")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("读未提交")]),t._v(" "),s("p",[t._v("允许读取尚未提交的更改。可能导致脏读、幻读或不可重复读。")])]),t._v(" "),s("li",[s("p",[t._v("读提交")]),t._v(" "),s("p",[t._v("允许从已经提交的并发事务读取。可防止脏读，但幻读和不可重复读仍可能会发生。")])]),t._v(" "),s("li",[s("p",[t._v("可重复读")]),t._v(" "),s("p",[t._v("对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻读仍可能发生")])]),t._v(" "),s("li",[s("p",[t._v("序列化")]),t._v(" "),s("p",[t._v("完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。")])])]),t._v(" "),s("h2",{attrs:{id:"spring声明式事务配置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#spring声明式事务配置"}},[t._v("#")]),t._v(" Spring声明式事务配置")]),t._v(" "),s("ol",[s("li",[t._v("事务的传播性：\n@Transactional(propagation=Propagation.REQUIRED)")]),t._v(" "),s("li",[t._v("事务的隔离级别：\n@Transactional(isolation = Isolation.READ_UNCOMMITTED)")])]),t._v(" "),s("h2",{attrs:{id:"transactional失效"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#transactional失效"}},[t._v("#")]),t._v(" @Transactional失效")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("异常被捕获\nSpring中事务提交还是回滚是根据调用的方法是否抛出异常来决定的，因此如果把异常捕获之后又不抛出的话，即使出了问题，事务还是会提交。")]),t._v(" "),s("div",{staticClass:"language-Java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("  "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Autowired")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ClassB")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Autowired")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ClassC")]),t._v(" c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Transactional")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("methodA")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n          b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("methodB")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("methodC")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Exception")]),t._v(" e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n          \n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])]),t._v(" "),s("li",[s("p",[t._v("@Transactional修饰了非public方法\n@Transactional只能用于 public 的方法上，否则事务不会失效，如果要用在非 public 方法上，可以开启AspectJ 代理模式。（默认代理模式CGlib）")])]),t._v(" "),s("li",[s("p",[t._v("同一个类中的方法调用")]),t._v(" "),s("div",{staticClass:"language-Java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("  "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Component")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("A")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Transactional")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("methodA")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n          "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("methodB")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n      \n      "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Transactional")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("methodB")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n          "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// do something")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("methodB的事务是不生效的，因为这里是同一个类中的调用（更确切的说是同一个类同一个对象中），Spring事务的原理是调用时检查@Transactional注解，然后生成代理类进行事务管理，但是内部调用时不会生成代理类（或者说默认不会），因此也就无法进行事务管理。")])]),t._v(" "),s("li",[s("p",[t._v("同一个类中, 一个未标注 @Transactional 的方法去调用标有 @Transactional 的方法, 事务会失效")])])]),t._v(" "),s("h2",{attrs:{id:"同一个类中事务方法调用解决方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#同一个类中事务方法调用解决方法"}},[t._v("#")]),t._v(" 同一个类中事务方法调用解决方法")]),t._v(" "),s("ul",[s("li",[t._v("方法拆分\n这是一种最简单的方法，也就是把上面例子中的methodB拆分到一个单独的类里面，这样就是一般情况下的事务调用")]),t._v(" "),s("li",[t._v("下面三种方法都是在methodB上添加@Transactional(propagation = Propagation.REQUIRES_NEW)之后进行的测试\n"),s("ul",[s("li",[t._v("使用AspectJ代理\n具体操作就是，application.yml中需要配置spring.aop.auto ：true，然后在启动类开启AspectJ代理，并暴露代理类：@EnableAspectJAutoProxy(exposeProxy = true)\n这样的话就可以在调用的时候获取到代理类，并进行方法调用："),s("div",{staticClass:"language-Java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TestClassA")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AopContext")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("currentProxy")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("insertB")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])]),t._v(" "),s("li",[t._v("从ApplicationContext获取Bean\n这个原理应该是和上面一样的，直从ApplicationContext中获取到当前Bean，然后再调用方法："),s("div",{staticClass:"language-Java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// applicationContext 可以自动注入")]),t._v("\n applicationContext"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getBean")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TestClassA")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("insertB")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])]),t._v(" "),s("li",[t._v("注入自身"),s("div",{staticClass:"language-Java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("  "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Component")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TestClassA")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Autowired")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TestClassA")]),t._v(" testClassA"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),t._v("用这种方法也可以使methodB的事务生效，但是需要注意的是，第一次生成的代理类和自动注入的代理类不是一个对象，也就是代码中this和testClassA不是同一个对象，并且testclassA中不会再次自动注入。\n所以如果methodB插入数据时需要当前对象的属性，这种方法便不能再使用")])])])])])}),[],!1,null,null,null);a.default=p.exports}}]);